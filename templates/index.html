{% extends "base.html" %}
{% block title %}TrendSonar{% endblock %}
{% block head %}
{% endblock %}
{% block content %}

    <!-- Mobile Menu -->
    <div id="mobileMenu" class="mobile-menu-overlay">
        <div class="mobile-menu-content">
            <div class="menu-header">
                <h3>ç­›é€‰é€‰é¡¹</h3>
                <button id="closeMobileMenu" style="font-size: 1.2rem; color: #9ca3af;">&times;</button>
            </div>
            
            <!-- Search moved to top bar -->

            <div class="menu-section">
                <div class="menu-label">æ—¶é—´èŒƒå›´</div>
                <div class="grid-3" id="mobileTimeOptions">
                    <!-- JS generated -->
                </div>
                <div id="mobileDateRange" class="flex-row" style="display:none; margin-top: 8px; align-items: center;">
                    <input type="date" id="mobileStartDate" class="input-text" style="flex:1; padding: 6px;">
                    <span style="color: #6b7280;">-</span>
                    <input type="date" id="mobileEndDate" class="input-text" style="flex:1; padding: 6px;">
                </div>
            </div>

            <div class="menu-section">
                <div class="menu-label">é¢†åŸŸç­›é€‰</div>
                <div id="mobileCategoryContainer" class="mobile-check-list">
                    <!-- JS Generated -->
                </div>
            </div>

            <div class="menu-section">
                <div class="menu-label">åœ°åŒºç­›é€‰</div>
                <div id="mobileRegionContainer" class="mobile-check-list">
                    <!-- JS Generated -->
                </div>
            </div>

            <div class="menu-section">
                <div class="menu-label">æ¥æºç­›é€‰</div>
                <div id="mobileSourceContainer" class="mobile-check-list">
                    <!-- JS Generated -->
                </div>
            </div>

            <div class="menu-section">
                <div class="menu-label">æ’åºæ–¹å¼</div>
                <div class="flex-row segmented">
                    <button class="btn-filter flex-1" data-sort="heat" id="mobileSortHeat">ğŸ”¥ æŒ‰çƒ­åº¦</button>
                    <button class="btn-filter flex-1" data-sort="date" id="mobileSortDate">ğŸ•’ æŒ‰æ—¶é—´</button>
                </div>
            </div>

            <button id="applyMobileFilter" class="btn-primary">ç¡®è®¤ç­›é€‰</button>
        </div>
    </div>

    <div class="container">
        <!-- Mobile Top Bar -->
        <div class="mobile-top-bar">
            <div class="mobile-search-group">
                <input type="text" id="mobileTopSearchInput" placeholder="æœç´¢æ–°é—» (æ”¯æŒè¯­ä¹‰)...">
                <button class="btn-icon-search" id="mobileTopSearchBtn">æœç´¢</button>
            </div>
            <button class="btn-more-filter" id="mobileMoreBtn">ç­›é€‰</button>
        </div>

        <!-- Desktop Toolbar -->
        <div class="desktop-toolbar">
            <div class="toolbar-row">
                <div class="filter-group">
                    <select id="desktopTimeSelect" class="select-filter">
                        <!-- JS generated -->
                    </select>
                    <div id="desktopDateRange" style="display:none; align-items: center;">
                        <div style="width: 1px; height: 16px; background: #e5e7eb; margin: 0 4px;"></div>
                        <input type="date" id="desktopStartDate" class="input-date" style="border: none; outline: none; width: 110px;">
                        <span style="color: #9ca3af; margin: 0 2px;">-</span>
                        <input type="date" id="desktopEndDate" class="input-date" style="border: none; outline: none; width: 110px;">
                    </div>
                </div>

                <div class="filter-group">
                    <button class="btn-filter" data-sort="heat" id="desktopSortHeat">ğŸ”¥ çƒ­åº¦</button>
                    <button class="btn-filter" data-sort="date" id="desktopSortDate">ğŸ•’ æ—¶é—´</button>
                </div>
            </div>

            <div style="display: flex; gap: 12px; align-items: center; width: 100%;">
                <div id="desktopRegionSelect" class="ms-container"></div>
                <div id="desktopCategorySelect" class="ms-container"></div>
                <div id="desktopSourceSelect" class="ms-container"></div>

                <div class="search-box" style="flex: 1;">
                    <input type="text" id="desktopSearchInput" class="input-text search-input-desktop" placeholder="ğŸ”æœç´¢æ–°é—» (æ”¯æŒæ¨¡ç³Šæœç´¢ä¸è¯­ä¹‰æœç´¢)...">
                </div>
            </div>
        </div>

        <!-- News List -->
        <div id="newsList" class="news-list">
            <!-- JS Generated Items -->
        </div>

        <div id="loadingState" class="loading-state">
            åŠ è½½ä¸­...
        </div>
    </div>

    <!-- Chat Widget -->
    <div id="chatBtn" class="chat-widget-btn">ğŸ’¬</div>
    <div id="chatWindow" class="chat-window">
        <div class="chat-header">
            <span>TrendSonar AI</span>
            <div class="chat-header-controls">
                <div id="modelSwitch" class="chat-switch" title="ç‚¹å‡»åˆ‡æ¢å¤‡ç”¨AI">Main</div>
                <button id="closeChat" style="color:white; font-size:1.2rem; cursor:pointer;">&times;</button>
            </div>
        </div>
        <div id="chatMessages" class="chat-messages">
            <div class="message ai">ä½ å¥½ï¼æˆ‘æ˜¯ TrendSonar æ–°é—»åŠ©æ‰‹ï¼Œæœ‰ä»€ä¹ˆå¯ä»¥å¸®ä½ ï¼Ÿ</div>
        </div>
        <div class="chat-input-area">
            <div class="chat-quick-questions">
                <div class="chat-chip" onclick="sendQuickMsg('ä»Šå¤©æœ‰å“ªäº›çƒ­ç‚¹æ–°é—»ï¼Ÿ')">ğŸ”¥ ä»Šå¤©æœ‰å“ªäº›çƒ­ç‚¹æ–°é—»ï¼Ÿ</div>
                <div class="chat-chip" onclick="sendQuickMsg('æ˜¨å¤©å‘ç”Ÿäº†ä»€ä¹ˆï¼Ÿ')">ğŸ“… æ˜¨å¤©å‘ç”Ÿäº†ä»€ä¹ˆï¼Ÿ</div>
            </div>
            <div class="chat-input-row">
                <input type="text" id="chatInput" class="chat-input" placeholder="è¾“å…¥é—®é¢˜...">
                <button id="chatSend" class="chat-send">å‘é€</button>
            </div>
        </div>
    </div>

{% endblock %}
{% block scripts %}
    <script src="/static/marked.min.js"></script>
    <script>
        // Global Error Handler for debugging
        window.onerror = function(msg, url, line, col, error) {
            console.error('Global Error:', msg, error);
            const loading = document.getElementById('loadingState');
            if (loading) {
                loading.classList.remove('hidden');
                loading.innerHTML += `<br><span style="color:red; font-size:0.8rem;">ç³»ç»Ÿé”™è¯¯: ${msg}</span>`;
            }
            return false;
        };

        // State
        const state = {
            list: [],
            page: 1,
            pageSize: 20,
            loading: false,
            hasMore: true,
            isGenerating: false, // Global lock for manual summary generation
            filter: {
                q: '',
                source: '',
                category: 'all',
                region: '', // Added region filter
                sortBy: 'heat', // 'heat' | 'date'
                dateOption: 'today', // 'today', '24h', '3d', '7d', 'week', 'month', 'custom', 'other'
                startDate: new Date().toISOString().split('T')[0],
                endDate: new Date().toISOString().split('T')[0]
            },
            chat: {
                isOpen: false,
                isSending: false,
                useBackup: false
            }
        };

        // Constants
        // Remove static NEWS_CATEGORIES, fetch from API
        const TIME_OPTIONS = [
            { label: 'ä»Šæ—¥', value: 'today' },
            { label: '24å°æ—¶', value: '24h' },
            { label: '3å¤©å†…', value: '3d' },
            { label: '7å¤©å†…', value: '7d' },
            { label: 'æœ¬å‘¨', value: 'week' },
            { label: 'æœ¬æœˆ', value: 'month' },
            { label: 'ä»Šå¹´', value: 'year' },
            { label: 'æ‰€æœ‰æ—¶é—´', value: 'all' },
            { label: 'å…¶ä»–', value: 'other' }
        ];

        // DOM Elements
        const els = {
            mobileMenu: document.getElementById('mobileMenu'),
            mobileMoreBtn: document.getElementById('mobileMoreBtn'),
            closeMobileMenu: document.getElementById('closeMobileMenu'),
            applyMobileFilter: document.getElementById('applyMobileFilter'),
            
            mobileTopSearchInput: document.getElementById('mobileTopSearchInput'),
            mobileTopSearchBtn: document.getElementById('mobileTopSearchBtn'),
            desktopSearch: document.getElementById('desktopSearchInput'),
            
            mobileDateRange: document.getElementById('mobileDateRange'),
            mobileStartDate: document.getElementById('mobileStartDate'),
            mobileEndDate: document.getElementById('mobileEndDate'),

            desktopDateRange: document.getElementById('desktopDateRange'),
            desktopStartDate: document.getElementById('desktopStartDate'),
            desktopEndDate: document.getElementById('desktopEndDate'),
            
            mobileTimeContainer: document.getElementById('mobileTimeOptions'),
            desktopTimeSelect: document.getElementById('desktopTimeSelect'),
            
            // Updated IDs for Containers
            mobileCategoryContainer: document.getElementById('mobileCategoryContainer'),
            desktopCategorySelect: 'desktopCategorySelect', // ID string for class

            mobileRegionContainer: document.getElementById('mobileRegionContainer'),
            desktopRegionSelect: 'desktopRegionSelect',

            mobileSourceContainer: document.getElementById('mobileSourceContainer'),
            desktopSourceSelect: 'desktopSourceSelect',

            newsList: document.getElementById('newsList'),
            loading: document.getElementById('loadingState'),
            
            sortBtns: {
                mobileHeat: document.getElementById('mobileSortHeat'),
                mobileDate: document.getElementById('mobileSortDate'),
                desktopHeat: document.getElementById('desktopSortHeat'),
                desktopDate: document.getElementById('desktopSortDate')
            },

            chatBtn: document.getElementById('chatBtn'),
            chatWindow: document.getElementById('chatWindow'),
            closeChat: document.getElementById('closeChat'),
            chatMessages: document.getElementById('chatMessages'),
            chatInput: document.getElementById('chatInput'),
            chatSend: document.getElementById('chatSend'),
            modelSwitch: document.getElementById('modelSwitch')
        };

        // MultiSelect Class
        class MultiSelect {
            constructor(containerId, placeholder, options, selectedValues, onChange) {
                this.container = document.getElementById(containerId);
                this.placeholder = placeholder;
                this.options = options || [];
                this.selected = new Set(selectedValues ? selectedValues.split(',').filter(x=>x && x!=='all') : []);
                this.onChange = onChange;
                this.render();
            }

            render() {
                if (!this.container) return;
                this.container.innerHTML = '';
                
                // Trigger
                const trigger = document.createElement('div');
                trigger.className = 'ms-trigger';
                this.updateTriggerText(trigger);
                trigger.onclick = (e) => {
                    e.stopPropagation();
                    this.toggleDropdown();
                };
                this.container.appendChild(trigger);
                
                // Dropdown
                const dropdown = document.createElement('div');
                dropdown.className = 'ms-dropdown';
                this.dropdown = dropdown;
                
                // Search (only if many options)
                if (this.options.length > 8) {
                    const searchBox = document.createElement('div');
                    searchBox.className = 'ms-search';
                    const input = document.createElement('input');
                    input.placeholder = 'æœç´¢...';
                    input.onclick = (e) => e.stopPropagation();
                    input.onkeyup = (e) => {
                        const term = e.target.value.toLowerCase();
                        dropdown.querySelectorAll('.ms-option').forEach(opt => {
                            const txt = opt.textContent.toLowerCase();
                            opt.style.display = txt.includes(term) ? 'flex' : 'none';
                        });
                    };
                    searchBox.appendChild(input);
                    dropdown.appendChild(searchBox);
                }
                
                // Options
                this.options.forEach(opt => {
                    const row = document.createElement('div');
                    row.className = 'ms-option';
                    
                    const cb = document.createElement('input');
                    cb.type = 'checkbox';
                    cb.checked = this.selected.has(opt.value);
                    
                    row.onclick = (e) => {
                        e.stopPropagation();
                        // Toggle
                        if (this.selected.has(opt.value)) this.selected.delete(opt.value);
                        else this.selected.add(opt.value);
                        
                        cb.checked = this.selected.has(opt.value);
                        this.updateTriggerText(trigger);
                        // Immediate callback
                        this.onChange(Array.from(this.selected).join(','));
                    };
                    
                    // Prevent double toggle if clicking directly on checkbox
                    cb.onclick = (e) => {
                        e.stopPropagation();
                        if (e.target.checked) this.selected.add(opt.value);
                        else this.selected.delete(opt.value);
                        this.updateTriggerText(trigger);
                        this.onChange(Array.from(this.selected).join(','));
                    };
                    
                    row.appendChild(cb);
                    row.appendChild(document.createTextNode(opt.label));
                    dropdown.appendChild(row);
                });
                
                this.container.appendChild(dropdown);
            }
            
            updateTriggerText(el) {
                if (this.selected.size === 0) {
                    el.textContent = this.placeholder;
                } else if (this.selected.size === 1) {
                     const val = Array.from(this.selected)[0];
                     const opt = this.options.find(o => o.value === val);
                     el.textContent = opt ? opt.label : val;
                } else {
                    el.textContent = `${this.placeholder} (${this.selected.size})`;
                }
            }
            
            toggleDropdown() {
                // Close others
                document.querySelectorAll('.ms-dropdown.show').forEach(d => {
                    if (d !== this.dropdown) d.classList.remove('show');
                });
                this.dropdown.classList.toggle('show');
            }

            updateSelected(newValString) {
                 this.selected = new Set(newValString ? newValString.split(',').filter(x=>x && x!=='all') : []);
                 this.render(); 
            }
        }

        // Global instances
        let msRegion, msCategory, msSource;

        // Mobile List Render
        function renderMobileCheckList(container, options, selectedValues, onChange) {
            if (!container) return;
            container.innerHTML = '';
            const selected = new Set(selectedValues ? selectedValues.split(',').filter(x=>x && x!=='all') : []);
            
            options.forEach(opt => {
                const row = document.createElement('div');
                row.className = 'mobile-check-item ' + (selected.has(opt.value) ? 'checked' : '');
                
                const cb = document.createElement('input');
                cb.type = 'checkbox';
                cb.checked = selected.has(opt.value);
                
                row.onclick = () => {
                    if (selected.has(opt.value)) selected.delete(opt.value);
                    else selected.add(opt.value);
                    
                    cb.checked = selected.has(opt.value);
                    row.classList.toggle('checked', cb.checked);
                    onChange(Array.from(selected).join(','));
                };
                
                cb.onclick = (e) => e.stopPropagation();
                cb.onchange = (e) => {
                     if (e.target.checked) selected.add(opt.value);
                     else selected.delete(opt.value);
                     row.classList.toggle('checked', e.target.checked);
                     onChange(Array.from(selected).join(','));
                };
                
                row.appendChild(cb);
                row.appendChild(document.createTextNode(opt.label));
                container.appendChild(row);
            });
        }

        // --- Initialization ---
        async function init() {
            renderTimeOptions();
            
            // Load filters
            await Promise.all([fetchRegions(), fetchCategories(), fetchSources()]);
            
            // Set chat state
            state.chat.isOpen = false;
            els.chatWindow.classList.toggle('show', state.chat.isOpen);
            
            updateUIState();
            bindEvents();
            bindChatEvents();
            fetchNews(true);
            
            // Global click to close dropdowns
            document.addEventListener('click', (e) => {
                if (!e.target.closest('.ms-container')) {
                    document.querySelectorAll('.ms-dropdown.show').forEach(d => d.classList.remove('show'));
                }
            });
        }

        // --- Event Binding ---
        function bindEvents() {
            // Mobile Menu
            els.mobileMoreBtn.onclick = () => els.mobileMenu.classList.add('show');
            els.closeMobileMenu.onclick = () => els.mobileMenu.classList.remove('show');
            els.mobileMenu.onclick = (e) => {
                if(e.target === els.mobileMenu) els.mobileMenu.classList.remove('show');
            };

            // Search
            const onSearch = (e) => {
                if (e.key === 'Enter') {
                    state.filter.q = e.target.value;
                    els.mobileTopSearchInput.value = state.filter.q;
                    els.desktopSearch.value = state.filter.q;
                    fetchNews(true);
                }
            };
            els.mobileTopSearchInput.onkeyup = onSearch;
            els.desktopSearch.onkeyup = onSearch;
            
            els.mobileTopSearchBtn.onclick = () => {
                state.filter.q = els.mobileTopSearchInput.value;
                els.desktopSearch.value = state.filter.q;
                fetchNews(true);
            };

            // Date Range
            const onDateChange = (e, type) => {
                const val = e.target.value;
                if (type === 'start') state.filter.startDate = val;
                else state.filter.endDate = val;
                
                els.mobileStartDate.value = state.filter.startDate;
                els.desktopStartDate.value = state.filter.startDate;
                els.mobileEndDate.value = state.filter.endDate;
                els.desktopEndDate.value = state.filter.endDate;
                
                if (!isMobile() && state.filter.startDate && state.filter.endDate) {
                    fetchNews(true);
                }
            };
            
            els.mobileStartDate.onchange = (e) => onDateChange(e, 'start');
            els.desktopStartDate.onchange = (e) => onDateChange(e, 'start');
            els.mobileEndDate.onchange = (e) => onDateChange(e, 'end');
            els.desktopEndDate.onchange = (e) => onDateChange(e, 'end');

            // Time Select
            els.desktopTimeSelect.onchange = (e) => {
                setTimeOption(e.target.value);
            };

            // Sort
            const setSort = (val) => {
                state.filter.sortBy = val;
                updateUIState();
                if (!isMobile()) fetchNews(true);
            };
            els.sortBtns.mobileHeat.onclick = () => setSort('heat');
            els.sortBtns.mobileDate.onclick = () => setSort('date');
            els.sortBtns.desktopHeat.onclick = () => setSort('heat');
            els.sortBtns.desktopDate.onclick = () => setSort('date');

            // Mobile Apply
            els.applyMobileFilter.onclick = () => {
                state.filter.q = els.mobileTopSearchInput.value;
                els.desktopSearch.value = state.filter.q;
                els.mobileMenu.classList.remove('show');
                fetchNews(true);
            };

            // Scroll
            window.onscroll = () => {
                if ((window.innerHeight + window.scrollY) >= document.body.offsetHeight - 200) {
                    fetchNews();
                }
            };
        }
        
        // --- Fetch & Render Filters ---
        async function fetchRegions() {
            try {
                const res = await fetch('/api/regions');
                if(!res.ok) throw new Error(res.status);
                const list = await res.json();
                const options = list.map(r => ({label: r, value: r}));
                
                // Desktop
                msRegion = new MultiSelect(els.desktopRegionSelect, 'å…¨éƒ¨åœ°åŒº', options, state.filter.region, (val) => {
                    state.filter.region = val;
                    // Sync Mobile
                    renderMobileCheckList(els.mobileRegionContainer, options, val, (v) => { state.filter.region = v; });
                    fetchNews(true);
                });
                
                // Mobile
                renderMobileCheckList(els.mobileRegionContainer, options, state.filter.region, (val) => {
                    state.filter.region = val;
                    // Sync Desktop
                    if(msRegion) msRegion.updateSelected(val);
                });
                
            } catch (e) { 
                console.error("Fetch Regions Error:", e);
                msRegion = new MultiSelect(els.desktopRegionSelect, 'åŠ è½½å¤±è´¥', [], '', ()=>{});
            }
        }

        async function fetchCategories() {
            try {
                const res = await fetch('/api/categories');
                if(!res.ok) throw new Error(res.status);
                const list = await res.json();
                const options = list.map(c => ({label: c, value: c}));
                
                msCategory = new MultiSelect(els.desktopCategorySelect, 'å…¨éƒ¨é¢†åŸŸ', options, state.filter.category, (val) => {
                    state.filter.category = val;
                    renderMobileCheckList(els.mobileCategoryContainer, options, val, (v) => { state.filter.category = v; });
                    fetchNews(true);
                });
                
                renderMobileCheckList(els.mobileCategoryContainer, options, state.filter.category, (val) => {
                    state.filter.category = val;
                    if(msCategory) msCategory.updateSelected(val);
                });
                
            } catch (e) { 
                console.error("Fetch Categories Error:", e);
                msCategory = new MultiSelect(els.desktopCategorySelect, 'åŠ è½½å¤±è´¥', [], '', ()=>{});
            }
        }

        async function fetchSources() {
            try {
                const res = await fetch('/api/sources');
                if(!res.ok) throw new Error(res.status);
                const list = await res.json();
                const options = list.map(s => ({label: s, value: s}));
                
                msSource = new MultiSelect(els.desktopSourceSelect, 'å…¨éƒ¨æ¥æº', options, state.filter.source, (val) => {
                    state.filter.source = val;
                    renderMobileCheckList(els.mobileSourceContainer, options, val, (v) => { state.filter.source = v; });
                    fetchNews(true);
                });
                
                renderMobileCheckList(els.mobileSourceContainer, options, state.filter.source, (val) => {
                    state.filter.source = val;
                    if(msSource) msSource.updateSelected(val);
                });
                
            } catch (e) { 
                console.error("Fetch Sources Error:", e);
                msSource = new MultiSelect(els.desktopSourceSelect, 'åŠ è½½å¤±è´¥', [], '', ()=>{});
            }
        }

        function renderTimeOptions() {
             const createBtn = (opt) => {
                const btn = document.createElement('button');
                btn.className = 'btn-filter';
                btn.textContent = opt.label;
                btn.dataset.val = opt.value;
                btn.onclick = () => setTimeOption(opt.value);
                return btn;
            };
            els.mobileTimeContainer.innerHTML = '';
            TIME_OPTIONS.forEach(opt => els.mobileTimeContainer.appendChild(createBtn(opt)));
            
            // Desktop Select
            els.desktopTimeSelect.innerHTML = '';
             TIME_OPTIONS.forEach(opt => {
                const o = document.createElement('option');
                o.value = opt.value;
                o.textContent = opt.label;
                els.desktopTimeSelect.appendChild(o);
            });
        }

        function bindChatEvents() {
            els.chatBtn.onclick = () => {
                state.chat.isOpen = !state.chat.isOpen;
                els.chatWindow.classList.toggle('show', state.chat.isOpen);
                if(state.chat.isOpen) els.chatInput.focus();
            };
            
            els.closeChat.onclick = () => {
                state.chat.isOpen = false;
                els.chatWindow.classList.remove('show');
            };
            
            els.modelSwitch.onclick = () => {
                state.chat.useBackup = !state.chat.useBackup;
                els.modelSwitch.classList.toggle('active', state.chat.useBackup);
                els.modelSwitch.innerText = state.chat.useBackup ? "Backup" : "Main";
            };
            
            window.sendQuickMsg = (text) => {
                if (state.chat.isSending) return;
                els.chatInput.value = text;
                sendMsg();
            };

            const sendMsg = async () => {
                const text = els.chatInput.value.trim();
                if (!text || state.chat.isSending) return;
                
                // User Message
                appendMessage(text, 'user');
                els.chatInput.value = '';
                
                state.chat.isSending = true;
                els.chatSend.disabled = true;
                els.chatSend.innerText = '...';
                
                // AI Placeholder with animated status
                const aiMsgId = appendMessage('...', 'ai');
                const aiMsgEl = document.getElementById(aiMsgId);
                
                const statusMessages = ['ğŸ¤” æ€è€ƒä¸­...', 'ğŸ” æŸ¥è¯¢ä¸­...', 'ğŸ“ å‡†å¤‡å›å¤...'];
                let statusIdx = 0;
                aiMsgEl.innerHTML = `<span style="color:var(--text-light); font-style:italic;">${statusMessages[0]}</span>`;
                
                const statusTimer = setInterval(() => {
                    statusIdx = (statusIdx + 1) % statusMessages.length;
                    aiMsgEl.innerHTML = `<span style="color:var(--text-light); font-style:italic;">${statusMessages[statusIdx]}</span>`;
                }, 2000);
                
                try {
                    const params = new URLSearchParams({
                        query: text,
                        stream: 'true',
                        use_backup: state.chat.useBackup
                    });
                    
                    const response = await fetch(`/api/chat?${params.toString()}`);
                    if (!response.ok) throw new Error("API Error");
                    
                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    
                    let fullText = ""; // Accumulate full text for markdown parsing
                    let isFirstChunk = true;

                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;
                        
                        if (isFirstChunk) {
                            clearInterval(statusTimer);
                            isFirstChunk = false;
                        }
                        
                        const chunk = decoder.decode(value, { stream: true });
                        fullText += chunk;
                        
                        // Parse markdown and update
                        aiMsgEl.innerHTML = marked.parse(fullText);
                        
                        // Auto scroll
                        els.chatMessages.scrollTop = els.chatMessages.scrollHeight;
                    }
                    
                } catch (e) {
                    clearInterval(statusTimer);
                    aiMsgEl.innerText += "\n[å‡ºé”™: " + e.message + "]";
                } finally {
                    clearInterval(statusTimer); // Ensure timer is cleared
                    state.chat.isSending = false;
                    els.chatSend.disabled = false;
                    els.chatSend.innerText = 'å‘é€';
                }
            };
            
            els.chatSend.onclick = sendMsg;
            els.chatInput.onkeyup = (e) => {
                if (e.key === 'Enter') sendMsg();
            };
        }
        
        function appendMessage(text, role) {
            const id = 'msg-' + Date.now() + Math.random().toString(36).substr(2, 9);
            const div = document.createElement('div');
            div.className = `message ${role}`;
            div.id = id;
            div.innerText = text;
            els.chatMessages.appendChild(div);
            els.chatMessages.scrollTop = els.chatMessages.scrollHeight;
            return id;
        }

            // Cleanup old functions that are replaced
            // fetchSources, fetchRegions, renderFilterOptions are now redefined above


        // --- Logic Helper ---
        function isMobile() {
            return window.innerWidth < 768;
        }

        function getEffectiveDate() {
            if (state.filter.dateOption === 'other') return ''; // Using startDate/endDate instead
            if (state.filter.dateOption === 'today') return new Date().toISOString().split('T')[0];
            return state.filter.dateOption; // Returns '24h', '3d' etc.
        }

        function setTimeOption(val) {
            state.filter.dateOption = val;
            
            // Show/Hide date ranges based on selection
            const showRange = (val === 'other');
            els.mobileDateRange.style.display = showRange ? 'flex' : 'none';
            els.desktopDateRange.style.display = showRange ? 'flex' : 'none';

            if (val === 'today') {
                const t = new Date().toISOString().split('T')[0];
                state.filter.startDate = t;
                state.filter.endDate = t;
            } else if (val !== 'other') {
                // Clear custom dates if not using range
                state.filter.startDate = '';
                state.filter.endDate = '';
            }
            
            // Sync UI values
            els.mobileStartDate.value = state.filter.startDate;
            els.desktopStartDate.value = state.filter.startDate;
            els.mobileEndDate.value = state.filter.endDate;
            els.desktopEndDate.value = state.filter.endDate;

            updateUIState();
            if (!isMobile() && val !== 'other') fetchNews(true);
        }

        // renderFilterOptions is replaced by renderTimeOptions called in init

        function updateUIState() {
            // Update Mobile Buttons
            const updateBtns = (container) => {
                Array.from(container.children).forEach(btn => {
                    if (btn.tagName === 'BUTTON') {
                        if (btn.dataset.val === state.filter.dateOption) {
                            btn.classList.add('active');
                        } else {
                            btn.classList.remove('active');
                        }
                    }
                });
            };
            updateBtns(els.mobileTimeContainer);

            // Update Desktop Select
            const isPredefined = TIME_OPTIONS.some(o => o.value === state.filter.dateOption);
            if (isPredefined) {
                 els.desktopTimeSelect.value = state.filter.dateOption;
            }

            // Update Sort Buttons
            const s = state.filter.sortBy;
            const setSortActive = (btn, active) => {
                if (active) btn.classList.add('active');
                else btn.classList.remove('active');
            };
            setSortActive(els.sortBtns.mobileHeat, s === 'heat');
            setSortActive(els.sortBtns.mobileDate, s === 'date');
            setSortActive(els.sortBtns.desktopHeat, s === 'heat');
            setSortActive(els.sortBtns.desktopDate, s === 'date');
            
            // Sync Date Input (if visible)
            els.mobileStartDate.value = state.filter.startDate;
            els.desktopStartDate.value = state.filter.startDate;
            els.mobileEndDate.value = state.filter.endDate;
            els.desktopEndDate.value = state.filter.endDate;
        }

        function renderNewsList() {
            els.newsList.innerHTML = '';
            state.list.forEach((item, index) => {
                const card = document.createElement('div');
                card.className = 'news-card';
                
                const timeStr = new Date(item.time).toLocaleString('zh-CN', {month:'numeric', day:'numeric', hour:'numeric', minute:'numeric'});
                const hasRelated = item.sources && item.sources.length > 1;
                const sentimentLabel = (item.sentiment_label || 'æœªåˆ†æ').trim();
                let sentimentClass = 'sent-neu';
                if (sentimentLabel === 'æ­£é¢') sentimentClass = 'sent-pos';
                else if (sentimentLabel === 'è´Ÿé¢') sentimentClass = 'sent-neg';

                card.innerHTML = `
                    <div class="card-body">
                        <div class="rank">${index + 1}</div>
                        <div class="content">
                            <div class="news-head">
                                <a href="${item.url}" target="_blank" class="news-title">${item.title}</a>
                            </div>
                            
                            <div class="meta-row">
                                <div class="meta-left">
                                    <span class="tag tag-category">${item.category || 'å…¶ä»–'}</span>
                                    <span class="tag tag-heat">ğŸ”¥ ${item.heat.toFixed(1)}</span>
                                    <span class="tag sentiment-pill ${sentimentClass}">
                                        ${sentimentLabel}${item.sentiment_score !== undefined ? 'ï¼š' + item.sentiment_score : ''}
                                    </span>
                                </div>
                                <div class="meta-right">
                                    <span class="time-str">${timeStr}</span>
                                    ${item.sources && item.sources.length > 0 ? `
                                        <div class="related-dropdown">
                                            <button class="btn-link" onclick="toggleRelated(${item.id})">ğŸ”— å…³è”æŠ¥é“ (${item.sources.length}) â–¼</button>
                                            <div class="related-content" id="related-${item.id}">
                                                ${item.sources.map(src => `
                                                    <div class="related-item">
                                                        <span style="flex:1; margin-right:8px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${src.name || 'æœªçŸ¥æ¥æº'}</span>
                                                        <a href="${src.url}" target="_blank" class="related-link">æŸ¥çœ‹åŸæ–‡ â†—</a>
                                                    </div>
                                                `).join('')}
                                            </div>
                                        </div>
                                    ` : ''}
                                </div>
                            </div>

                            <div class="summary-box" id="summary-${item.id}">
                                ${renderSummaryHtml(item.summary, item.id)}
                            </div>
                        </div>
                    </div>
                `;
                els.newsList.appendChild(card);
            });
        }

        // --- API Actions ---
        async function fetchNews(reset = false) {
            if (state.loading) return;
            if (reset) {
                state.page = 1;
                state.list = [];
                state.hasMore = true;
                els.newsList.innerHTML = ''; // Clear immediately
            }
            if (!state.hasMore) return;

            state.loading = true;
            els.loading.textContent = 'åŠ è½½ä¸­...';
            els.loading.classList.remove('hidden');

            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 15000); // 15s timeout

            try {
                const params = new URLSearchParams({
                    q: state.filter.q,
                    category: (state.filter.category === 'all') ? '' : state.filter.category,
                    region: state.filter.region,
                    source: (state.filter.source === 'all') ? '' : state.filter.source,
                    sort_by: state.filter.sortBy,
                    page: state.page,
                    page_size: state.pageSize,
                    date: getEffectiveDate()
                });
                
                // Add start/end date if 'other' is selected
                if (state.filter.dateOption === 'other') {
                    if (state.filter.startDate) params.append('start_date', state.filter.startDate);
                    if (state.filter.endDate) params.append('end_date', state.filter.endDate);
                }

                const res = await fetch(`/api/news?${params.toString()}`, { signal: controller.signal });
                clearTimeout(timeoutId);
                
                if (!res.ok) throw new Error(`HTTP Error ${res.status}`);
                const data = await res.json();
                
                if (data.data.length < state.pageSize) {
                    state.hasMore = false;
                    els.loading.textContent = '- åˆ°åº•äº† -';
                } else {
                    els.loading.classList.add('hidden');
                }

                if (reset) state.list = data.data;
                else state.list = state.list.concat(data.data);
                
                state.page++;
                renderNewsList(); 
            } catch (err) {
                console.error(err);
                if (err.name === 'AbortError') {
                    els.loading.innerHTML = 'è¯·æ±‚è¶…æ—¶ã€‚<br><button class="btn-link" onclick="fetchNews(true)">ç‚¹å‡»é‡è¯•</button>';
                } else {
                    els.loading.innerHTML = `åŠ è½½å¤±è´¥: ${err.message}<br><button class="btn-link" onclick="fetchNews(true)">ç‚¹å‡»é‡è¯•</button>`;
                }
            } finally {
                state.loading = false;
            }
        }

        // Global functions for inline HTML events
        window.toggleRelated = (id) => {
            const el = document.getElementById(`related-${id}`);
            if (el) {
                // Close others if needed? No, let's keep it simple
                if (el.classList.contains('show')) el.classList.remove('show');
                else {
                    // Close all other open dropdowns first to keep UI clean
                    document.querySelectorAll('.related-content.show').forEach(d => d.classList.remove('show'));
                    el.classList.add('show');
                }
            }
        };

        window.toggleSummary = (id, showFull) => {
            const content = document.getElementById(`summary-content-${id}`);
            const btnExpand = document.getElementById(`btn-expand-${id}`);
            const btnCollapse = document.getElementById(`btn-collapse-${id}`);
            
            if (content && btnExpand && btnCollapse) {
                if (showFull) {
                    content.classList.remove('collapsed');
                    btnExpand.style.display = 'none';
                    btnCollapse.style.display = 'inline';
                } else {
                    content.classList.add('collapsed');
                    btnExpand.style.display = 'inline';
                    btnCollapse.style.display = 'none';

                    // æ”¶èµ·æ—¶æ»šåŠ¨å›æ–°é—»å¡ç‰‡é¡¶éƒ¨
                    const card = content.closest('.news-card');
                    if (card) {
                        const headerOffset = 80; // é¢„ç•™é¡¶éƒ¨å¯¼èˆªæ é«˜åº¦
                        const elementPosition = card.getBoundingClientRect().top;
                        const offsetPosition = elementPosition + window.scrollY - headerOffset;
                        
                        window.scrollTo({
                             top: offsetPosition,
                             behavior: "smooth"
                        });
                    }
                }
            }
        };

        function renderSummaryHtml(summary, id) {
            if (!summary) {
                return `
                    <div class="summary-placeholder">
                        <span>æš‚æ— æ‘˜è¦</span>
                        <button class="btn-link" onclick="genSummary(${id})">âœ¨ ç”Ÿæˆæ‘˜è¦</button>
                    </div>
                `;
            }
            
            // ä½¿ç”¨çº¯æ–‡æœ¬é•¿åº¦åˆ¤æ–­æ˜¯å¦éœ€è¦æŠ˜å ï¼Œé¿å…æˆªæ–­ HTML
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = summary;
            const textLength = tempDiv.innerText.length;
            const threshold = 300;
            
            if (textLength <= threshold) {
                return summary + ` <button class="btn-regen" onclick="genSummary(${id})">ğŸ”„ é‡æ–°ç”Ÿæˆ</button>`;
            } else {
                return `
                    <div id="summary-content-${id}" class="summary-content collapsed">
                        ${summary}
                    </div>
                    <button id="btn-expand-${id}" class="btn-link" onclick="toggleSummary(${id}, true)">æŸ¥çœ‹å…¨éƒ¨</button>
                    <button id="btn-collapse-${id}" class="btn-link" style="display:none;" onclick="toggleSummary(${id}, false)">æ”¶èµ·</button>
                    <button class="btn-regen" onclick="genSummary(${id})">ğŸ”„ é‡æ–°ç”Ÿæˆ</button>
                `;
            }
        }

        // Close dropdowns when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.related-dropdown')) {
                document.querySelectorAll('.related-content.show').forEach(d => d.classList.remove('show'));
            }
        });

        window.genSummary = async (id) => {
            if (state.isGenerating) return; // Prevent multiple concurrent
            
            const box = document.getElementById(`summary-${id}`);
            if (!box) return;
            
            state.isGenerating = true;
            updateRegenButtonsState();

            const originalContent = box.innerHTML;
            // Determine if it's regeneration or new generation
            const isRegen = box.querySelector('.btn-regen') !== null;
            
            if (isRegen) {
                // Find the regen button and change text
                const btn = box.querySelector('.btn-regen');
                if (btn) btn.innerText = "â³ ç”Ÿæˆä¸­...";
            } else {
                box.innerHTML = '<span style="color:var(--primary-color)">æ­£åœ¨ç”Ÿæˆæ‘˜è¦...</span>';
            }
            
            try {
                const res = await fetch(`/api/generate_summary/${id}`, { method: 'POST' });
                const data = await res.json();
                if (data.summary) {
                    // Update content and append regen button
                    box.innerHTML = renderSummaryHtml(data.summary, id);
                    
                    // Update local state
                    const item = state.list.find(i => i.id === id);
                    if (item) item.summary = data.summary;
                } else {
                    throw new Error("Empty summary");
                }
            } catch (err) {
                alert('ç”Ÿæˆå¤±è´¥');
                box.innerHTML = originalContent;
            } finally {
                state.isGenerating = false;
                updateRegenButtonsState();
            }
        };

        function updateRegenButtonsState() {
            // Disable/Enable all regen buttons and create summary buttons
            const regenBtns = document.querySelectorAll('.btn-regen');
            const createBtns = document.querySelectorAll('.summary-placeholder .btn-link');
            
            const setDisabled = (btn) => {
                btn.disabled = state.isGenerating;
                // è§†è§‰åé¦ˆç”± CSS :disabled é€‰æ‹©å™¨å¤„ç† btn-regen
                // å¯¹äº btn-linkï¼ˆæ–°å»ºï¼‰ï¼Œæˆ‘ä»¬å¯èƒ½éœ€è¦å†…è”æ ·å¼æˆ–ç±»
                if (state.isGenerating) btn.style.opacity = '0.5';
                else btn.style.opacity = '1';
                btn.style.cursor = state.isGenerating ? 'not-allowed' : 'pointer';
            };

            regenBtns.forEach(setDisabled);
            createBtns.forEach(setDisabled);
        }

        // Start
        init();
    </script>
{% endblock %}
